

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Fansong Yan">
  <meta name="keywords" content="技术、生活、游戏">
  
    <meta name="description" content="如何准备机器学习工程师的面试？相关说明这份文档是我为校招面试而准备的，最后并没有用上。许多的内容都来自于互联网和 ChatGPT，我只针对相关知识进行了简单梳理，并不保证全面和严谨。在撰写过程中几乎都是用人话写的，应该还算通俗，如果您觉得有所帮助，可以点个关注，谢谢。 注意：文档最初使用 markdown 写的，导入的时候行内公式没有正确转换，我手动修改了一些，但是仍有不少遗漏，敬请谅解。 特征工">
<meta property="og:type" content="article">
<meta property="og:title" content="如何准备机器学习工程师的面试？">
<meta property="og:url" content="http://songguokunsgg.github.io/2024/02/13/%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E9%9D%A2%E8%AF%95__EberyThingSay/index.html">
<meta property="og:site_name" content="菘菓菌 sgg">
<meta property="og:description" content="如何准备机器学习工程师的面试？相关说明这份文档是我为校招面试而准备的，最后并没有用上。许多的内容都来自于互联网和 ChatGPT，我只针对相关知识进行了简单梳理，并不保证全面和严谨。在撰写过程中几乎都是用人话写的，应该还算通俗，如果您觉得有所帮助，可以点个关注，谢谢。 注意：文档最初使用 markdown 写的，导入的时候行内公式没有正确转换，我手动修改了一些，但是仍有不少遗漏，敬请谅解。 特征工">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-02-13T21:23:56.000Z">
<meta property="article:modified_time" content="2024-08-01T05:42:30.067Z">
<meta property="article:author" content="Fansong Yan">
<meta property="article:tag" content="学术">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>如何准备机器学习工程师的面试？ - 菘菓菌 sgg</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"songguokunsgg.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"lvlxAX7h8N0UYVZ8XQr3vW7e-gzGzoHsz","app_key":"0RaTUR0yFhlAjxM4uYyXvPSj","server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>菘菓菌 sgg</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/technology-stack/" target="_self">
                <i class="iconfont icon-codepen-fill"></i>
                <span>技术栈</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="如何准备机器学习工程师的面试？"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Fansong Yan
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-02-13 21:23" pubdate>
          2024年2月13日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          10k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          87 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">如何准备机器学习工程师的面试？</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="如何准备机器学习工程师的面试？"><a href="#如何准备机器学习工程师的面试？" class="headerlink" title="如何准备机器学习工程师的面试？"></a>如何准备机器学习工程师的面试？</h1><h2 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h2><p>这份文档是我为校招面试而准备的，最后并没有用上。许多的内容都来自于互联网和 ChatGPT，我只针对相关知识进行了简单梳理，并不保证全面和严谨。在撰写过程中几乎都是用人话写的，应该还算通俗，如果您觉得有所帮助，可以点个关注，谢谢。</p>
<p>注意：文档最初使用 markdown 写的，导入的时候行内公式没有正确转换，我手动修改了一些，但是仍有不少遗漏，敬请谅解。</p>
<h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><h3 id="归一化以及标准化"><a href="#归一化以及标准化" class="headerlink" title="归一化以及标准化"></a>归一化以及标准化</h3><p>归一化（Normalization）和标准化（Standardization）是数据预处理的两种常用技术，它们都旨在处理数据特征的尺度问题，以便于进行后续的数据分析或模型训练。</p>
<h3 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h3><p>归一化通常是将数据按比例缩放，使之落入一个小的、特定的区间，常见的是将数据缩放到 [0, 1] 或者 [-1, 1] 的区间。</p>
<p><strong>作用</strong>：</p>
<ul>
<li>提高模型的收敛速度；</li>
<li>提高模型的精度。</li>
<li>原因 (统一数据尺度，加速梯度下降，避免梯度消失和梯度爆炸，正则化效果)</li>
</ul>
<p><strong>常用的归一化公式</strong>：</p>
<ol>
<li><strong>Min-Max 归一化</strong>：</li>
</ol>
<p>$ x_{\text{norm}} &#x3D; \frac{x - x_{\text{min}}}{x_{\text{max}} - x_{\text{min}}} $ </p>
<ol>
<li><strong>Max 归一化</strong>：</li>
</ol>
<p>$ x_{\text{norm}} &#x3D; \frac{x}{x_{\text{max}}} $ </p>
<h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h3><p>标准化通常是去均值、方差缩放，使数据符合<strong>标准正态分布</strong>，即均值为 0，标准差为 1。</p>
<p><strong>作用</strong>：</p>
<ul>
<li>使不同规模或单位的特征可比；</li>
<li>符合一些模型对数据分布的假设（例如 PCA、线性回归模型等）。</li>
</ul>
<p><strong>常用的标准化公式</strong>：</p>
<ol>
<li><strong>Z-score 标准化</strong>：</li>
</ol>
<p>$ x_{\text{std}} &#x3D; \frac{x - \mu}{\sigma} $ </p>
<p>其中$\mu$ 是均值， $\sigma$ 是标准差。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><strong>归一化</strong>通常应用在梯度下降、神经网络等模型中，这些模型对<strong>特征的尺度比较敏感</strong>;</li>
<li><strong>标准化</strong>适用于 PCA、逻辑回归、支持向量机等<strong>依赖于距离或梯度</strong>的模型。</li>
</ul>
<p>值得注意的是，归一化和标准化的选择需要依据具体的模型和问题场景来定。在某些场合下，原始的、非标准化的数据可能会带来更好的结果。所以，在模型训练时，合适尝试不同的数据预处理方法，以便找到最佳的策略。</p>
<h3 id="过滤方法（Filter-Methods）"><a href="#过滤方法（Filter-Methods）" class="headerlink" title="过滤方法（Filter Methods）"></a>过滤方法（Filter Methods）</h3><p>特征工程（Feature Engineering）包括特征选择和特征提取。”Filter” 通常指的是过滤方法（Filter Methods）。</p>
<p>过滤方法是一种特征选择技术，其主要目标是从原始特征集中<strong>选择出</strong>一部分最有用的、与目标变量最相关的<strong>特征子集</strong>。等于说是做了一次数据预处理，跟粗糙集特征选择是一样的。</p>
<p>与包装方法（Wrapper Methods）和嵌入方法（Embedded Methods）不同，过滤方法在特征选择的过程中<strong>不涉及到机器学习算法的学习过程</strong>。</p>
<p>其特点和步骤大致如下：</p>
<h3 id="1-与模型独立"><a href="#1-与模型独立" class="headerlink" title="1. 与模型独立"></a>1. 与模型独立</h3><p>不考虑模型的预测能力，而是依据每个特征与目标变量的相关性来进行选择。</p>
<p>相关性的衡量方式有很多种。</p>
<h3 id="2-评分机制"><a href="#2-评分机制" class="headerlink" title="2. 评分机制"></a>2. 评分机制</h3><p>为每个特征赋予一个分数，这个分数反映了该特征与响应变量之间的关系强度或者相关程度。</p>
<ul>
<li><strong>相关系数</strong>：衡量特征与目标变量之间的线性关系；</li>
<li><strong>卡方检验</strong>：用于衡量特征与类别之间的关系；</li>
<li><strong>互信息</strong>：衡量两个变量之间的依赖程度，可用于类别型和数值型变量；</li>
</ul>
<h3 id="3-选择子集"><a href="#3-选择子集" class="headerlink" title="3. 选择子集"></a>3. 选择子集</h3><p>根据每个特征的分数进行排序，并选取分数最高的 k 个特征作为最终的特征子集。</p>
<h3 id="4-粗糙集数据挖掘"><a href="#4-粗糙集数据挖掘" class="headerlink" title="4. 粗糙集数据挖掘"></a>4. 粗糙集数据挖掘</h3><p>同样有评分机制，但是并不需要指定特征数，选出维持正域不变的最小特征子集即可。</p>
<h3 id="作用和目的"><a href="#作用和目的" class="headerlink" title="作用和目的"></a>作用和目的</h3><ul>
<li><strong>降低计算成本</strong>：减少模型训练和预测所需要的计算资源；</li>
<li><strong>减轻过拟合</strong>：通过消除不相关或弱相关的特征，减少模型的过拟合风险；</li>
<li><strong>提高模型性能</strong>：在某些情况下，消除噪声特征可能帮助模型提高预测的准确性；</li>
<li><strong>增强模型的可解释性</strong>：更简洁的模型通常更容易解释和理解。</li>
</ul>
<p>过滤方法由于计算效率高、实现简单并且不依赖于特定模型，所以在特征选择的初始阶段经常被用来快速筛选特征。然后，你可能还需要利用其他特征选择方法来进一步优化特征集合。</p>
<h3 id="wrapper-包装方法"><a href="#wrapper-包装方法" class="headerlink" title="wrapper 包装方法"></a>wrapper 包装方法</h3><p>“Wrapper” 在特征工程中指的是包装方法（Wrapper Methods）。包装方法在特征选择过程中<strong>会考虑到模型的性能</strong>，进而找到一个理想的特征子集来优化模型的表现。</p>
<h3 id="包装方法的核心思想"><a href="#包装方法的核心思想" class="headerlink" title="包装方法的核心思想"></a>包装方法的核心思想</h3><ol>
<li><strong>依赖模型</strong>：</li>
<li>特征选择的过程是在模型训练的基础上完成的，也就是说模型的性能用来评价特征的好坏。</li>
<li><strong>搜索子集</strong>：</li>
<li>通过搜索特征的子集空间来找到最优的特征子集，即让模型在此子集上获得最佳的性能表现。</li>
</ol>
<h3 id="常见的包装方法包括"><a href="#常见的包装方法包括" class="headerlink" title="常见的包装方法包括"></a>常见的包装方法包括</h3><ol>
<li><strong>递归特征消除（Recursive Feature Elimination, RFE）</strong>：</li>
<li>该方法首先在全部特征上训练模型，然后移除最不重要的特征（例如模型权重最小的特征），再用剩下的特征重新训练模型。这个过程递归进行，直至达到预定的特征数量。</li>
<li><strong>前向选择（Forward Selection）</strong>：</li>
<li>开始时，模型没有任何特征。然后逐渐加入提升模型性能最大的特征。这一过程不断重复，直到加入新特征不再显著提升模型性能为止。</li>
<li><strong>后向消除（Backward Elimination）</strong>：</li>
<li>与前向选择相反，后向消除开始时使用所有特征，然后逐步移除对模型贡献最小的特征，直到移除任何一个特征都会损害模型性能为止。</li>
</ol>
<h3 id="包装方法的特点"><a href="#包装方法的特点" class="headerlink" title="包装方法的特点"></a>包装方法的特点</h3><ul>
<li><strong>优点</strong>：</li>
<li>考虑了模型性能，通常能找到更符合模型的特征子集。</li>
<li>在某些情况下，比过滤方法能更准确地找到最优的特征子集。</li>
<li><strong>缺点</strong>：</li>
<li>计算成本高。</li>
<li>过于依赖所选择的模型。如果选择的模型不佳，那么进行特征选择的结果也可能不理想。</li>
</ul>
<p>包装方法通常适用于特征数量相对较少的情况，或者当你准备花费更多的时间和计算资源来寻找最优特征子集的时候。</p>
<h3 id="ebedded-方法"><a href="#ebedded-方法" class="headerlink" title="ebedded 方法"></a>ebedded 方法</h3><p>在特征工程中，”Embedded”（嵌入法）是一种特征选择方法，它试图在模型训练过程中找到最重要的特征。不同于过滤方法（Filter Methods）和包装方法（Wrapper Methods），嵌入法在学习器训练过程中自动进行特征选择。</p>
<h3 id="嵌入方法（Embedded-Methods）"><a href="#嵌入方法（Embedded-Methods）" class="headerlink" title="嵌入方法（Embedded Methods）"></a>嵌入方法（Embedded Methods）</h3><h3 id="1-特征选择过程"><a href="#1-特征选择过程" class="headerlink" title="1. 特征选择过程"></a>1. 特征选择过程</h3><p>嵌入方法在模型训练的同时进行特征选择。这类方法通常会在模型训练过程中自动选择一个特征子集，通常依赖于模型自身的属性或参数。</p>
<h3 id="2-实现机制"><a href="#2-实现机制" class="headerlink" title="2. 实现机制"></a>2. 实现机制</h3><ul>
<li><strong>基于惩罚项</strong>：例如在岭回归（Ridge Regression）和套索回归（Lasso Regression）中，通过引入 L2 或 L1 正则项来缩减不重要特征的系数，进行特征选择。</li>
<li><strong>基于树模型</strong>：例如决策树和随机森林，它们在构建树的过程中自然地进行了特征选择，将<strong>重要的特征用于树的顶部分裂</strong>，而不重要的特征可能不会用于分裂或者出现在靠近叶子的位置。</li>
</ul>
<h3 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h3><ul>
<li>考虑到了模型和特征选择的互动，通常能获得比过滤方法更优的特征子集。</li>
<li>特征选择过程与模型训练过程结合在一起，<strong>计算效率较高</strong>。</li>
</ul>
<h3 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a>4. 缺点</h3><ul>
<li>依赖于模型选择的准确性，所选择的特征子集质量高低和所用模型有直接关系。</li>
<li>可解释性可能较差，特别是在使用一些复杂的非线性模型时。</li>
</ul>
<h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>L1 正则化和 L2 正则化是机器学习和统计学中常用的两种正则化技术。正则化是用来防止过拟合，并提高模型的泛化能力的一种方法。</p>
<ol>
<li><strong>定义</strong>:</li>
<li><strong>L1 正则化</strong>:</li>
</ol>
<ul>
<li>L1 正则化是指在损失函数中添加参数权重的绝对值之和，公式为 $\lambda \sum |w_i| $ ，其中 $\lambda \sum |w_i|$ 是模型参数， $\lambda$ 是正则化系数。</li>
</ul>
<ol>
<li><strong>L2 正则化</strong>:</li>
</ol>
<ul>
<li>L2 正则化是指在损失函数中添加参数权重的平方和，公式为 $ \lambda \sum w_i^2$ ，其中 $\lambda \sum w_i^2$ 是模型参数， $\lambda \sum w_i^2$ 是正则化系数。</li>
</ul>
<ol>
<li><strong>目的</strong>:</li>
<li><strong>L1 正则化</strong>和<strong>L2 正则化</strong>的主要目的都是通过在损失函数中添加额外的项来控制模型的复杂度，以防止过拟合和提高模型的泛化能力。</li>
<li><strong>稀疏性</strong>:</li>
<li><strong>L1 正则化</strong>能够产生稀疏解，即得到的参数向量中会有许多零值，这有助于特征选择。</li>
<li><strong>L2 正则化</strong>通常不会产生稀疏解，而是倾向于将参数向量中的所有元素都缩小，但不会将它们准确地设为零。</li>
<li><strong>解的唯一性</strong>:</li>
<li><strong>L1 正则化</strong>可能得到多个解，因为 L1 正则化的解空间可能在某些方向上是不连续的。</li>
<li><strong>L2 正则化</strong>总是得到唯一解，因为 L2 正则化的解空间是平滑的和连续的。</li>
<li><strong>解析解</strong>:</li>
<li><strong>L1 正则化</strong>通常没有解析解，需要使用迭代方法来求解。</li>
<li><strong>L2 正则化</strong>在某些情况下可以得到解析解，例如线性回归模型。</li>
<li><strong>计算复杂度</strong>:</li>
<li><strong>L1 正则化</strong>的计算可能更为复杂，因为它的解可能需要求解非线性的优化问题。</li>
<li><strong>L2 正则化</strong>的计算相对简单，因为它的解可以通过求解线性方程组得到。</li>
<li><strong>鲁棒性</strong>:</li>
<li><strong>L1 正则化</strong>对于异常值具有更好的鲁棒性，因为它倾向于产生稀疏解，忽略不重要的特征。</li>
<li><strong>L2 正则化</strong>可能对异常值较为敏感，因为它倾向于使用所有的特征。</li>
</ol>
<p>在实际应用中，选择 L1 正则化还是 L2 正则化通常取决于问题的具体需求和数据的特性。例如，如果特征选择是重要的考虑因素，可能会选择 L1 正则化；如果模型的稳定性和解的唯一性更为重要，可能会选择 L2 正则化。</p>
<h3 id="常用的嵌入方法技术"><a href="#常用的嵌入方法技术" class="headerlink" title="常用的嵌入方法技术"></a>常用的嵌入方法技术</h3><ol>
<li><strong>Lasso 回归</strong>：L1 正则化可以将不重要的特征系数压缩至零，自然地实现了特征的选择。</li>
</ol>
<p>$ J(\theta) &#x3D; \text{MSE} + \alpha \sum_{i&#x3D;1}^{n} |\theta_i| $ </p>
<ol>
<li><strong>决策树</strong>：通过信息增益或基尼不纯度等指标，在构建树的过程中进行特征选择。</li>
<li><strong>正则化网络</strong>：例如 Elastic Net，结合了 L1 和 L2 正则化，同时兼顾特征选择和模型的稳健性。</li>
<li><strong>支持向量机</strong>：使用线性核的 SVM 并引入 L1 正则化，可以在分类的同时进行特征选择。</li>
</ol>
<p>嵌入方法由于直接考虑到了模型的学习过程，通常在保证模型性能的同时能够获得较为精简的特征子集。不过，最终选择哪种特征选择方法还需结合实际问题的需求和特点来决定。</p>
<h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><h3 id="准确率和召回率"><a href="#准确率和召回率" class="headerlink" title="准确率和召回率"></a>准确率和召回率</h3><p>准确率（Precision）和召回率（Recall）是分类模型性能评估的两个重要指标，它们分别关注了模型预测正类样本的准确性和完整性。这两个指标常常和其他指标一起用来评估模型在正类预测上的表现。</p>
<h3 id="1-准确率（Precision）"><a href="#1-准确率（Precision）" class="headerlink" title="1. 准确率（Precision）"></a>1. 准确率（Precision）</h3><p>准确率关注的是模型预测为正类的样本中有多少是真正的正类样本。其计算公式为：</p>
<p>$ \text{Precision} &#x3D; \frac{\text{TP}}{\text{TP} + \text{FP}} $ </p>
<p>其中，TP（True Positive）是真正类（模型预测为正类，实际也为正类）的样本数量，FP（False Positive）是假正类（模型预测为正类，实际为负类）的样本数量。</p>
<h3 id="2-召回率（Recall）"><a href="#2-召回率（Recall）" class="headerlink" title="2. 召回率（Recall）"></a>2. 召回率（Recall）</h3><p>召回率关注的是实际所有正类样本中有多少被模型预测出来了。其计算公式为：</p>
<p>$ \text{Recall} &#x3D; \frac{\text{TP}}{\text{TP} + \text{FN}} $ </p>
<p>其中，FN（False Negative）是假负类（模型预测为负类，实际为正类）的样本数量。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><strong>关注点不同</strong>：准确率关注的是预测为正类的样本中实际正类的比例，而召回率关注的是实际正类样本中被正确预测出的比例。</li>
<li><strong>权衡关系</strong>：在多数情况下，准确率和召回率呈现一种权衡的关系，提高准确率可能会降低召回率，反之亦然。这种权衡关系通常使用 F1 分数（F1 Score）来综合衡量，其计算公式为：</li>
</ul>
<p>$ F1 &#x3D; 2 \times \frac{\text{Precision} \times \text{Recall}}{\text{Precision} + \text{Recall}} $ </p>
<ul>
<li><strong>应用场景</strong>：在某些场景下，我们可能更关心准确率，比如在垃圾邮件检测中，我们不希望重要邮件被误判为垃圾邮件。在其他场景下，我们可能更关心召回率，例如在疾病检测中，我们不希望漏检任何一个病患。</li>
</ul>
<h3 id="P-R-曲线"><a href="#P-R-曲线" class="headerlink" title="P-R 曲线"></a>P-R 曲线</h3><p>P-R 曲线（Precision-Recall Curve）是一种用于评估二元分类模型（Binary Classification）性能的工具。该曲线绘制了在不同决策阈值下，模型的准确率（Precision）和召回率（Recall）之间的关系。在一些实际问题（特别是在正负类样本不平衡的情况下）中，P-R 曲线是一个很有用的工具，因为它关注的重点是正类的预测能力。</p>
<h3 id="P-R-曲线与-ROC-曲线的区别"><a href="#P-R-曲线与-ROC-曲线的区别" class="headerlink" title="P-R 曲线与 ROC 曲线的区别"></a>P-R 曲线与 ROC 曲线的区别</h3><ul>
<li>关注点不同：P-R 曲线关注的是正类的预测性能，而 ROC 曲线同时考虑了正类和负类的预测性能。</li>
<li>Y 轴标度不同：P-R 曲线的 Y 轴是 Precision，而 ROC 曲线的 Y 轴是 True Positive Rate（也叫做 Recall 或敏感性）。</li>
<li>选择依据：在正负样本<strong>严重不均衡</strong>的情况下，P-R 曲线通常更能反映模型对正类样本预测的真实情况。</li>
</ul>
<h3 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h3><p>参数调优（Hyperparameter Tuning）是机器学习中一个关键的步骤，它涉及到在给定的搜索空间中寻找模型表现最优的参数配置。对模型的参数进行优化可以显著提高模型的预测能力。下面简单介绍几种常用的参数调优方法：网格搜索、随机搜索以及贝叶斯优化。</p>
<h3 id="1-网格搜索（Grid-Search）-穷举法"><a href="#1-网格搜索（Grid-Search）-穷举法" class="headerlink" title="1. 网格搜索（Grid Search）(穷举法)"></a>1. 网格搜索（Grid Search）(穷举法)</h3><p>网格搜索是一种穷举搜索方法。它通过预先定义好的参数范围和取值，生成参数组合的“网格”，然后遍历这些组合来寻找最优参数。</p>
<ul>
<li><strong>优点</strong>：理论上能找到最优参数组合（至少在你设定的范围和步长内）。</li>
<li><strong>缺点</strong>：计算量大，尤其是当参数空间较大或模型较复杂时。</li>
</ul>
<h3 id="2-随机搜索（Random-Search）-网格中抽样"><a href="#2-随机搜索（Random-Search）-网格中抽样" class="headerlink" title="2. 随机搜索（Random Search）(网格中抽样)"></a>2. 随机搜索（Random Search）(网格中抽样)</h3><p>不同于网格搜索，随机搜索并不尝试所有可能的参数组合，而是在参数空间中随机抽样，根据这些样本来找到最优参数。</p>
<ul>
<li><strong>优点</strong>：比网格搜索更高效，尤其是在参数空间较大时；并且在实践中，随机搜索通常能够在相对较少的迭代次数中找到不错的参数组合。</li>
<li><strong>缺点</strong>：没有网格搜索精确，可能错过某些参数组合。</li>
</ul>
<h3 id="3-贝叶斯优化（Bayesian-Optimization）"><a href="#3-贝叶斯优化（Bayesian-Optimization）" class="headerlink" title="3. 贝叶斯优化（Bayesian Optimization）"></a>3. 贝叶斯优化（Bayesian Optimization）</h3><p>贝叶斯优化使用概率模型（通常是高斯过程）来预测在哪里可以找到有效的参数组合，并据此进行下一步的搜索，因此，它在每一步迭代时都会<strong>考虑到之前的搜索结果</strong>。</p>
<ul>
<li><strong>优点</strong>：相比于网格搜索和随机搜索，贝叶斯优化通常能更快地找到最优参数组合；并且它可以更有效地利用有限的资源。</li>
<li><strong>缺点</strong>：建立和调优概率模型可能在某些情况下比直接进行参数搜索更为复杂和计算密集。</li>
</ul>
<h3 id="过拟合与欠拟合"><a href="#过拟合与欠拟合" class="headerlink" title="过拟合与欠拟合"></a>过拟合与欠拟合</h3><p>欠拟合和过拟合是机器学习中常见的两种模型表现问题。它们描述了模型与数据之间的关系，以及模型对新数据的泛化能力。</p>
<h3 id="欠拟合（Underfitting）"><a href="#欠拟合（Underfitting）" class="headerlink" title="欠拟合（Underfitting）"></a>欠拟合（Underfitting）</h3><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>当模型过于简单，无法捕捉到数据中的模式和关系时，我们称之为欠拟合。一个欠拟合的模型在训练数据和测试数据上的表现都会较差。</p>
<h3 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h3><ol>
<li><strong>使用更复杂的模型</strong>：例如，对于线性回归，可以尝试多项式回归。</li>
<li><strong>增加特征</strong>：引入更多的特征，或者构建特征的组合。</li>
<li><strong>减少正则化</strong>：如果使用了正则化技术（如 L1 或 L2 正则化），尝试减小正则化系数。</li>
</ol>
<h3 id="过拟合（Overfitting）"><a href="#过拟合（Overfitting）" class="headerlink" title="过拟合（Overfitting）"></a>过拟合（Overfitting）</h3><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>当模型过于复杂，不仅学习了数据中的真实模式，还学习了数据中的噪声，我们称之为过拟合。一个过拟合的模型在训练数据上的表现很好，但在测试数据上的表现较差，因为它对新的、未见过的数据泛化能力较差。</p>
<h3 id="如何避免-1"><a href="#如何避免-1" class="headerlink" title="如何避免"></a>如何避免</h3><ol>
<li><strong>获取更多的数据</strong>：更多的数据可以帮助模型泛化得更好。</li>
<li><strong>使用简化的模型</strong>：例如，从神经网络中减少隐藏层或隐藏单元。</li>
<li><strong>添加正则化</strong>：如 L1 或 L2 正则化，这可以约束模型的复杂性。</li>
<li><strong>特征选择</strong>：减少不相关或冗余的特征。</li>
<li><strong>早停</strong>：对于某些迭代的模型（如神经网络），当验证误差停止减少或开始增加时，停止训练。</li>
<li><strong>使用集成方法</strong>：如 Bagging 和 Boosting，通过组合多个模型的预测来减少过拟合。</li>
<li><strong>交叉验证</strong>：使用交叉验证选择模型的超参数，以确保模型在多个子集上的表现都较好。</li>
<li><strong>剪枝</strong>：对于决策树等模型，减少模型的深度或叶节点数量。</li>
</ol>
<h3 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h3><h3 id="支持向量机-SVM"><a href="#支持向量机-SVM" class="headerlink" title="支持向量机 (SVM)"></a>支持向量机 (SVM)</h3><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>支持向量机（Support Vector Machine，SVM）是一种用于分类和回归的监督学习算法。在分类问题中，SVM 试图找到一个超平面，最大化两个类别之间的边缘（margin），即数据点到超平面的最小距离。</p>
<h3 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h3><p>基本的线性 SVM 分类器求解的问题可以表述为以下优化问题：</p>
<p>$ \min_{\mathbf{w}, b} \frac{1}{2}|\mathbf{w}|^2\ s.t.\ y_i(\mathbf{w} \cdot \mathbf{x}_i + b) \geq 1, \quad i &#x3D; 1, \ldots, N $ </p>
<p>这里：</p>
<ul>
<li>$\lambda \sum w_i^2$ 是超平面的法向量</li>
<li>$b$ 是超平面的偏置项</li>
<li>$ \lambda \sum w_i^2$ 是数据点</li>
<li>$y_i$ 是数据点对应的类别标签（通常是 +1 或 -1）</li>
</ul>
<h3 id="对偶和-KKT-条件"><a href="#对偶和-KKT-条件" class="headerlink" title="对偶和 KKT 条件"></a>对偶和 KKT 条件</h3><p>对偶问题是指从原始优化问题（Primal Problem）出发，通过一些数学变换得到的另一个问题。对于 SVM 来说，我们可以用拉格朗日乘子法把原始问题转化为它的对偶问题，这使得问题的求解更加高效，并允许我们用核技巧（Kernel trick）来处理非线性问题。</p>
<p>KKT（Karush-Kuhn-Tucker）条件提供了一个检查某个点是否是优化问题解的必要和充分条件。在 SVM 中，KKT 条件允许我们确定一个数据点是否是支持向量。</p>
<h3 id="优劣势"><a href="#优劣势" class="headerlink" title="优劣势"></a>优劣势</h3><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li><strong>泛化能力强</strong>：在很多实际问题中，SVM 具有较好的泛化性能。</li>
<li><strong>处理非线性问题</strong>：通过核技巧，SVM 可以处理非线性问题。</li>
<li><strong>全局最优解</strong>：SVM 的解是全局最优的，而不是局部最优。</li>
<li><strong>稀疏性</strong>：只有支持向量会参与到最终模型的决策中。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><strong>核函数选择</strong>：正确选择或构造核函数可能比较困难。</li>
<li><strong>大规模数据</strong>：在大规模数据集上，SVM 的计算复杂度较高，训练过程可能比较耗时。</li>
<li><strong>多分类问题</strong>：标准的 SVM 只适用于二分类问题。虽然可以通过一些策略（例如“一对一”或“一对其余”）来解决多分类问题，但这些策略在某些场景下可能不是很有效。</li>
</ol>
<p>注意：以上内容仅为概述性的讨论。具体的公式推导、对偶问题、KKT 条件等涉及较深入的数学理论和技术细节，您可能需要参考相关教材或研究文章以获取更深入的理解和洞察。</p>
<h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><h3 id="1-ID3-算法"><a href="#1-ID3-算法" class="headerlink" title="1. ID3 算法"></a>1. ID3 算法</h3><h3 id="最大信息增益公式"><a href="#最大信息增益公式" class="headerlink" title="最大信息增益公式"></a>最大信息增益公式</h3><p>信息增益（Information Gain, IG）表示得知特征 $X$ 的信息而使得类 $Y$ 的信息的不确定性减少的程度。计算公式如下：</p>
<p>$ IG(Y|X) &#x3D; H(Y) - H(Y|X) $ </p>
<p>$ 信息增益&#x3D;Y 熵-X 下 Y 条件熵 $ </p>
<p>其中， $H(Y)$ 是数据集 $D$ 的熵（Entropy）, 计算公式为：</p>
<p>$ H(Y) &#x3D; -\sum_{i&#x3D;1}^{m} p(y_i) \log_2 p(y_i) $ </p>
<p>而条件熵 $X$ 表示在已知随机变量 $X$ 的条件下随机变量 $Y$ 的不确定性，计算公式为：</p>
<p>$ H(Y|X) &#x3D; \sum_{i&#x3D;1}^{n} p(x_i) H(Y|x_i) $ </p>
<h3 id="2-C4-5-算法"><a href="#2-C4-5-算法" class="headerlink" title="2. C4.5 算法"></a>2. C4.5 算法</h3><h3 id="最大信息增益率公式"><a href="#最大信息增益率公式" class="headerlink" title="最大信息增益率公式"></a>最大信息增益率公式</h3><p>C4.5 算法使用信息增益率（Gain Ratio）来选择分裂特征，计算公式如下：</p>
<p>$ GR(Y|X) &#x3D; \frac{IG(Y|X)}{IV(X)} $ </p>
<p>其中，信息增益 $G(X|Y)$ 与 ID3 中的定义相同，而固有值 $IV(X)$ 定义为：</p>
<p>$ IV(X) &#x3D; -\sum_{i&#x3D;1}^{n} p(x_i) \log_2 p(x_i) $ </p>
<h3 id="信息增益率更好的原因"><a href="#信息增益率更好的原因" class="headerlink" title="信息增益率更好的原因"></a>信息增益率更好的原因</h3><ol>
<li><strong>偏向处理</strong>:</li>
<li><strong>信息增益</strong>倾向于选择具有更多值的属性，因为这样的属性能更好地区分数据，但可能导致过拟合。</li>
<li><strong>信息增益率</strong>在信息增益的基础上除以一个称为属性固有值（Intrinsic Value）的值，从而减轻了对具有多个值的属性的偏见。</li>
<li><strong>模型泛化能力</strong>:</li>
<li>通过减轻对具有更多类别的特征的偏见，<strong>信息增益率</strong>可能会提高模型的泛化能力，使模型在未见过的数据上表现得更好。</li>
<li><strong>特征选择的准确性</strong>:</li>
<li><strong>信息增益率</strong>通过<strong>固有值的归一化</strong>来提供更准确的特征选择，从而可能会导致建立一个更简单和更有效的模型。</li>
<li><strong>处理连续和离散属性</strong>:</li>
<li>在处理连续属性时，<strong>信息增益率</strong>可能提供更好的特征选择，因为它能减轻信息增益对高度区分的特征的偏好。</li>
</ol>
<h3 id="3-CART-算法"><a href="#3-CART-算法" class="headerlink" title="3. CART 算法"></a>3. CART 算法</h3><h3 id="基尼指数公式"><a href="#基尼指数公式" class="headerlink" title="基尼指数公式"></a>基尼指数公式</h3><p>CART 使用基尼指数（Gini Index）来选择分裂点，基尼指数反映了从数据集$D$中随机抽取两个样本，其类标记不一致的概率，计算公式为：</p>
<p>$ Gini(D) &#x3D; 1 - \sum_{i&#x3D;1}^{m} p^2(y_i) $ </p>
<p>对于二分类问题，该公式可以简化为：</p>
<p>$ Gini(D) &#x3D; 2p(1-p) $ </p>
<p>其中，$p$是正类样本的比例。</p>
<h3 id="回归树步骤"><a href="#回归树步骤" class="headerlink" title="回归树步骤"></a>回归树步骤</h3><p>对于回归树，CART 会尝试找到使得<strong>划分后的子集内的样本目标值的方差最小的特征</strong>进行分裂。</p>
<ol>
<li>遍历所有的特征及其可能的取值，找到最佳的特征及其取值作为分裂依据。</li>
<li>使用选定的特征和取值进行分裂，生成子节点。</li>
<li>对子节点递归调用以上步骤，生成决策树。</li>
</ol>
<h3 id="三种树的区别"><a href="#三种树的区别" class="headerlink" title="三种树的区别"></a>三种树的区别</h3><ul>
<li><strong>ID3</strong>：使用信息增益来选择特征，可能倾向于选择取值较多的特征。</li>
<li><strong>C4.5</strong>：使用信息增益率来选择特征，修正了 ID3 的缺点，计算相对复杂。</li>
<li><strong>CART</strong>：可以用于分类（使用基尼指数）和回归（使用均方误差）问题，生成的是二叉树。</li>
</ul>
<p>现有的算法几乎都使用 C4.5 和 CART。在 sklearn 中，两种算法除了分裂标准不同外，其余都类似，都生成二叉树。</p>
<h3 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h3><h3 id="GBDT-Gradient-Boosting-Decision-Tree"><a href="#GBDT-Gradient-Boosting-Decision-Tree" class="headerlink" title="GBDT (Gradient Boosting Decision Tree)"></a>GBDT (Gradient Boosting Decision Tree)</h3><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>GBDT 是一种迭代的决策树算法，它通过拟合<strong>残差</strong>来生成每一棵树，将所有树的结果累加起来作为最终预测输出。</p>
<h3 id="残差"><a href="#残差" class="headerlink" title="残差"></a>残差</h3><ol>
<li><strong>残差的定义</strong>:</li>
<li>数学上，如果用 $y $ 表示实际的观测值，用 $\hat{y}$ 表示当前模型的预测值，那么残差 $r$ 可以定义为 $\hat{y}$ 。代表实际观测值与当前模型的预测值之间的差异。</li>
<li><strong>残差的计算和利用</strong>:</li>
<li>在每一轮的迭代中，GBDT 都会计算当前模型对每个训练样本的残差。然后，它会构建一个新的决策树来拟合这些残差，而不是直接拟合实际的观测值。</li>
<li>通过这种方式，每个新的决策树都试图纠正前一个模型的错误。</li>
<li><strong>模型的更新</strong>:</li>
<li>在构建了新的决策树之后，GBDT 会将其加入到当前的模型中，以更新模型的预测，引入了学习率来防止过拟合。</li>
<li><strong>梯度的角色</strong>:</li>
<li>实际上，残差是损失函数相对于模型预测的负梯度。在每一轮的迭代中，通过计算和拟合残差，GBDT 实际上是在执行梯度下降算法来最小化损失函数。</li>
<li><strong>损失函数的选择</strong>:</li>
<li>GBDT 可以用于回归和分类问题，通过选择不同的损失函数，比如平方损失、对数损失等，可以使 GBDT 适用于不同类型的问题。残差的计算方式会根据所选择的损失函数而有所不同。</li>
</ol>
<h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><ol>
<li><strong>初始化</strong>：用一个常数值来预测，通常是目标变量的均值。</li>
<li><strong>迭代</strong>：在每次迭代中：</li>
<li>计算残差（真实值与当前模型的预测值之差）。</li>
<li>使用残差作为目标变量 (这里有点难理解，其实是不用原来的决策类了，而是用残差当作的新的决策类来进行训练) 训练一个基学习器（通常是一个决策树）。</li>
<li>将基学习器的预测结果乘以一个步长（学习率）加到模型中。</li>
<li><strong>输出</strong>：所有树的预测结果相加，得到最终的预测值。</li>
</ol>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>适用于回归和分类问题。</li>
<li>能处理混合类型的特征。</li>
<li>有较好的解释性。</li>
</ul>
<h3 id="XGBoost-Extreme-Gradient-Boosting"><a href="#XGBoost-Extreme-Gradient-Boosting" class="headerlink" title="XGBoost (Extreme Gradient Boosting)"></a>XGBoost (Extreme Gradient Boosting)</h3><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p>XGBoost 也是一种基于树的集成模型，它基于 GBDT，并在速度和性能上做了很多优化和改进。</p>
<h3 id="优化与改进"><a href="#优化与改进" class="headerlink" title="优化与改进"></a>优化与改进</h3><ol>
<li><strong>正则化</strong>：在目标函数中加入了正则化项，用来控制模型的复杂度，防止过拟合。</li>
<li><strong>优化目标函数</strong>：使用了一阶和二阶梯度信息，在寻找最佳分裂点时考虑到了增益的一阶和二阶导数。</li>
<li><strong>稀疏感知算法</strong>：能自动处理稀疏数据，也能自定义缺失值的处理方式。</li>
<li><strong>列抽样</strong>：通过列抽样来防止过拟合，增强模型的泛化能力。</li>
<li><strong>并行化</strong>：在特征划分上进行并行计算，大大提升了速度。</li>
</ol>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>在精度上通常优于其他算法。</li>
<li>在使用上提供了大量的可调参数。</li>
<li>具有很强的灵活性，能自定义优化目标和评价准则。</li>
<li>可以高效地处理大规模数据集。</li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h3 id="平方差损失"><a href="#平方差损失" class="headerlink" title="平方差损失"></a>平方差损失</h3><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>平方差损失（Mean Squared Error, MSE）常用于回归问题，计算模型预测值与真实值之间的平方差的平均值。表达式为：</p>
<p>$ MSE &#x3D; \frac{1}{n}\sum_{i&#x3D;1}^{n}(y_i - \hat{y}_i)^2 $ </p>
<p>其中， $y_i$ 是真实值，$\hat{y}$ 是模型的预测值，n 是样本数量。</p>
<h3 id="梯度下降公式推导"><a href="#梯度下降公式推导" class="headerlink" title="梯度下降公式推导"></a>梯度下降公式推导</h3><p>对于参数 $\theta$ 的梯度，可以通过对 $\theta$ 求导来获得：</p>
<p>$ \frac{\partial MSE}{\partial \theta} &#x3D; \frac{-2}{n}\sum_{i&#x3D;1}^{n}(y_i - \hat{y}_i)\frac{\partial \hat{y}_i}{\partial \theta} $ </p>
<p>在具体的模型（如线性回归模型）中，$\hat{y}_i$ 会是 $\theta$ 的具体函数形式，从而可以进一步推导梯度表达式。</p>
<h3 id="凸函数"><a href="#凸函数" class="headerlink" title="凸函数"></a>凸函数</h3><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>凸函数是一种在整个定义域内上凸的函数。对于定义在某个凸集 C 上的函数 f，如果对于任意的 $x_1, x_2 \in C$ 和任意的 $ \alpha \in [0,1]$，都有：</p>
<p>$ f(\alpha x_1 + (1-\alpha)x_2) \leq \alpha f(x_1) + (1-\alpha)f(x_2) $ </p>
<p>则称函数 $f$ 是凸函数。凸函数的一个重要性质是：局部最小值也是全局最小值。</p>
<h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>梯度下降是一种优化算法，主要用于寻找函数的局部最小值。基本思想是在每一步迭代中，找到函数在当前点的梯度方向，并沿着梯度方向的负方向移动一定的步长，以此来更新参数值：</p>
<p>$ \theta_{t+1} &#x3D; \theta_{t} - \alpha \nabla f(\theta_t) $ </p>
<p>其中，$\theta$ 是需要优化的参数，$\alpha$ 是学习率，$\nabla f(\theta_t)$ 是 $f$ 在 $\theta_t$ 处的梯度。</p>
<h3 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h3><p>牛顿法是一种在实数域和复数域上近似求解方程的迭代方法。在优化问题中，牛顿法主要用于求解无约束优化问题的极值。牛顿法更新参数的公式为：</p>
<p>$ \theta_{t+1} &#x3D; \theta_{t} - \left[ Hf(\theta_t) \right]^{-1} \nabla f(\theta_t) $ </p>
<p>其中，$\theta$ 是需要优化的参数，</p>
<p>$ Hf(\theta_t) $ </p>
<p>是$f$在 $\theta_t$ 处的海森矩阵（Hessian Matrix，即梯度的导数矩阵）。</p>
<p>总结来说，平方差损失、凸函数、梯度下降、牛顿法这些概念和方法在机器学习的模型训练过程中经常被用到，分别在损失函数定义、函数性质探讨、参数优化等方面发挥着重要作用。</p>
<h3 id="正则化和稀疏性-重点内容"><a href="#正则化和稀疏性-重点内容" class="headerlink" title="正则化和稀疏性 (重点内容)"></a>正则化和稀疏性 (重点内容)</h3><h3 id="正则化（Regularization）"><a href="#正则化（Regularization）" class="headerlink" title="正则化（Regularization）"></a>正则化（Regularization）</h3><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>正则化是机器学习模型为了防止过拟合而在损失函数中添加的一个额外项，通常是模型参数的函数。加入正则化项后，模型在训练过程中不仅要最小化原来的损失函数，还要最小化正则化项，从而防止模型复杂度过高。</p>
<h3 id="主要形式"><a href="#主要形式" class="headerlink" title="主要形式"></a>主要形式</h3><ul>
<li><strong>L1 正则化</strong>：模型参数权重绝对值之和，表达式形式： $   L_1 &#x3D; \lambda \sum_{i&#x3D;1}^{n} |\theta_i|   $</li>
<li><strong>L2 正则化</strong>：模型参数权重平方和的平方根，表达式形式： $   L_2 &#x3D; \lambda \sum_{i&#x3D;1}^{n} \theta_i^2   $</li>
</ul>
<p>其中，$\theta$ 是模型参数，$\lambda$ 是正则化强度参数。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><strong>防止过拟合</strong>：通过约束模型参数的大小，防止模型过于复杂。</li>
<li><strong>模型选择</strong>：在一定程度上起到了特征选择的作用（特别是 L1 正则化）。</li>
</ul>
<h3 id="稀疏性（Sparsity）"><a href="#稀疏性（Sparsity）" class="headerlink" title="稀疏性（Sparsity）"></a>稀疏性（Sparsity）</h3><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>稀疏性在机器学习中通常是指模型的一部分参数或者特征为零，即模型或数据中有大量的零元素。</p>
<h3 id="与正则化的关系"><a href="#与正则化的关系" class="headerlink" title="与正则化的关系"></a>与正则化的关系</h3><ul>
<li><strong>L1 正则化与稀疏性</strong>：L1 正则化倾向于产生稀疏解，即模型的一部分参数会被压缩为 0，起到了特征选择的效果。</li>
<li><strong>L2 正则化与稀疏性</strong>：L2 正则化倾向于让模型的参数接近 0 但不为 0，得到的模型一般不是稀疏的。</li>
</ul>
<h3 id="稀疏性的好处"><a href="#稀疏性的好处" class="headerlink" title="稀疏性的好处"></a>稀疏性的好处</h3><ol>
<li><strong>计算效率</strong>：稀疏矩阵的存储和运算通常比密集矩阵更加高效。</li>
<li><strong>解释性</strong>：稀疏模型通常更容易解释，因为模型只依赖于一部分特征。</li>
<li><strong>泛化能力</strong>：通过减少模型依赖的特征数量，可能提高模型的泛化能力。</li>
</ol>
<h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><h3 id="CNN（卷积神经网络）"><a href="#CNN（卷积神经网络）" class="headerlink" title="CNN（卷积神经网络）"></a>CNN（卷积神经网络）</h3><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><strong>卷积层</strong>：通过卷积操作进行特征提取。卷积核（或滤波器）在输入数据上滑动，通过卷积操作提取空间特征。</li>
<li><strong>激活层</strong>：通常在卷积层之后，使用非线性激活函数，如 ReLU，增强网络的表达能力。</li>
<li><strong>池化层</strong>：进行下采样，减小数据的空间尺寸，以减少计算量，并增强特征的鲁棒性。</li>
</ul>
<p>假设我们有一个 4x4 的特征图如下：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span> <span class="hljs-number">3</span>  <span class="hljs-number">2</span>  <span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span> <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span><br><span class="hljs-symbol">13 </span><span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure>
<p>我们使用一个 2x2 的池化窗口和步长为 2 的最大池化操作。在这种情况下，我们将 4x4 的特征图分为四个 2x2 的区域，并从每个区域中选取最大值。步长为 2 意味着池化窗口每次移动两个单位。</p>
<ul>
<li>第一个 2x2 区域（左上角）的最大值是 6</li>
<li>第二个 2x2 区域（右上角）的最大值是 8</li>
<li>第三个 2x2 区域（左下角）的最大值是 14</li>
<li>第四个 2x2 区域（右下角）的最大值是 16</li>
</ul>
<p>因此，经过最大池化操作后，我们得到一个新的 2x2 的特征图：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span> <span class="hljs-number">8</span><br><span class="hljs-symbol">14 </span><span class="hljs-number">16</span><br></code></pre></td></tr></table></figure>
<p>通过这个操作，我们保留了每个区域的最大值，同时将特征图的尺寸减小了。</p>
<ul>
<li><strong>全连接层</strong>：将学到的空间特征用于最终的分类或回归任务。</li>
</ul>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>适合处理图像数据，能够有效提取图像的局部特征。</li>
<li>权值共享：减少模型参数，缓解过拟合。</li>
<li>空间不变性：通过权值共享和池化层，模型能够对输入数据的微小变化保持不变。</li>
</ul>
<h3 id="RNN（循环神经网络）"><a href="#RNN（循环神经网络）" class="headerlink" title="RNN（循环神经网络）"></a>RNN（循环神经网络）</h3><h3 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><strong>循环结构</strong>：RNN 通过循环结构实现序列数据的时间依赖捕捉。</li>
<li><strong>隐藏状态</strong>：在每个时间步，RNN 通过当前输入和前一时间步的隐藏状态来更新当前的隐藏状态。</li>
<li><strong>时间展开</strong>：虽然 RNN 的结构是循环的，但在实际计算和分析中，通常将其在时间上展开以方便理解和计算。</li>
</ul>
<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul>
<li>适合处理序列数据，如文本、时间序列数据等。</li>
<li>能够理论上捕捉时间序列中的长期依赖关系。</li>
<li>容易受到梯度消失或梯度爆炸问题的困扰。</li>
</ul>
<h3 id="变体"><a href="#变体" class="headerlink" title="变体"></a>变体</h3><ul>
<li><strong>LSTM（长短时记忆网络）</strong>：通过引入<strong>门机制</strong>和单元状态来缓解梯度消失问题，能够更好地捕捉序列中的长期依赖关系。</li>
<li><strong>GRU（门控循环单元）</strong>：类似 LSTM 但结构更简单，计算参数更少。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>CNN</strong> 主要用于处理具有空间结构的数据（如图像）。</li>
<li><strong>RNN</strong> 主要用于处理具有时间依赖关系的序列数据（如文本）。</li>
</ul>
<p>这两种网络结构在深度学习领域有着广泛的应用，并且在图像识别、自然语言处理等任务上取得了显著的成功。</p>
<h3 id="Attention-Mechanism"><a href="#Attention-Mechanism" class="headerlink" title="Attention Mechanism"></a>Attention Mechanism</h3><p><strong>Attention Mechanism</strong> 的核心思想在于赋予模型对输入数据不同部分关注（或称注意）的能力。在自然语言处理中，尤其在序列到序列的模型中，Attention 机制帮助模型在不同阶段关注输入序列的不同部分，从而更好地解码出目标序列。</p>
<h3 id="Self-Attention"><a href="#Self-Attention" class="headerlink" title="Self-Attention"></a>Self-Attention</h3><p><strong>Self-Attention</strong> 是 Attention 机制的一种变体，它允许模型在同一序列内部的不同位置之间进行关注。不同于传统的 Attention 机制将关注点放在一个不同的序列上（如在翻译任务中，对源序列进行关注），Self-Attention 则是在同一序列的不同位置上计算注意力权重。</p>
<h3 id="计算步骤"><a href="#计算步骤" class="headerlink" title="计算步骤"></a>计算步骤</h3><ol>
<li><strong>计算查询（Query）、键（Key）和值（Value）</strong>：对于输入序列中的每个位置，我们都会得到一个 Query、一个 Key 和一个 Value，它们通常是通过不同的参数化可学习的线性变换得到的。</li>
</ol>
<p>$ Q &#x3D; XW_Q, K &#x3D; XW_K, V &#x3D; XW_V $ </p>
<p>其中，$X$ 是输入序列，$W_Q, W_K, W_V$ 是对应的权重矩阵。</p>
<ol>
<li><strong>计算注意力权重</strong>：用 Query 和 Key 的点积计算注意力分数，再通过 softmax 函数获取权重。</li>
</ol>
<p>$ AttentionScores &#x3D; softmax\left(\frac{QK^T}{\sqrt{d_k}}\right) $ </p>
<p>这里，$d_k$ 是 Key 的维度，除以 $\sqrt{d_k}$ 是为了缓解梯度消失或爆炸的问题。</p>
<ol>
<li><strong>计算加权和</strong>：利用得到的注意力权重和 Value 的线性组合得到输出。</li>
</ol>
<p>$ Z &#x3D; AttentionScores \times V $ </p>
<h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>自适应关注</strong>：Self-Attention 允许模型自适应地关注输入序列中不同位置的信息，有助于捕捉序列内部的依赖关系。</li>
<li><strong>并行计算</strong>：不同于 RNN 需要顺序计算序列的每一个位置，Self-Attention 可以并行计算序列所有位置的输出，从而在计算上更加高效。</li>
<li><strong>多头注意力</strong>：在实际应用中，我们通常使用多头注意力（Multi-Head Attention）来捕捉序列中的多种依赖关系。不同的注意力头可以学习到序列中不同层次的信息。</li>
</ul>
<h3 id="应用：Transformer-模型"><a href="#应用：Transformer-模型" class="headerlink" title="应用：Transformer 模型"></a>应用：Transformer 模型</h3><p>Self-Attention 机制在 <strong>Transformer</strong> 模型中得到了广泛应用。Transformer 模型基于 Self-Attention 来处理序列数据，摒弃了传统的 RNN 结构，充分利用 Self-Attention 的并行性和强大的表达能力，成为了现代自然语言处理模型（例如 BERT、GPT 等）的核心组成部分。</p>
<h2 id="简历相关"><a href="#简历相关" class="headerlink" title="简历相关"></a>简历相关</h2><h3 id="论文简介"><a href="#论文简介" class="headerlink" title="论文简介"></a>论文简介</h3><p>论文 1：主要基于课题组内部的相关族算法进行了改进，引入了正域覆盖度的概念，提高算法抗噪声性能，且不牺牲算法效率。</p>
<p>论文 2：首次提出了专为单调有序数据设计的数据粒化策略，并依此策略设计了高效的单调特征选择和分类算法，相比传统优势粗糙集的特征选择算法提升了数百倍效率。</p>
<p>论文 3：首次将模糊数学引入单调有序数据中，增强了论文 2 中算法处理连续值属性的能力。还将并行计算和样本抽样引入了算法中，进一步提升计算效率。</p>
<h3 id="AI-框架简介"><a href="#AI-框架简介" class="headerlink" title="AI 框架简介"></a>AI 框架简介</h3><p>技术手段：nodejs、Juia、HTML、mongodb</p>
<h3 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h3><p>主要用于前端脚本的编写，实现页面逻辑。优势在于语法简单，容易实现，可跨平台等。</p>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>主要用于前端页面的编写，实现界面呈现和用户交互等，配合 nodejs 使用。</p>
<h3 id="Julia"><a href="#Julia" class="headerlink" title="Julia"></a>Julia</h3><p>出于对高性能计算的考虑，选择 Julia 作为后端框架，使用 HTTP、JSON、MLBase 等库辅助编写。</p>
<h3 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h3><p>非关系型数据库，在未来有数据存储需求后考虑引入。</p>
<h3 id="PCA-算法"><a href="#PCA-算法" class="headerlink" title="PCA 算法"></a>PCA 算法</h3><p>主成分分析（Principal Component Analysis, PCA）是一种广泛应用的线性降维技术，旨在从数据中找出最重要的特征并降低数据的维度，以减小计算成本和提高模型性能。以下是 PCA 算法的主要步骤和特点：</p>
<ol>
<li><strong>中心化数据</strong>:</li>
</ol>
<ul>
<li>首先，计算每个特征的均值，并将数据中心化，即从每个特征值中减去该特征的均值。</li>
<li>数据规模 $n\times m$</li>
</ul>
<ol>
<li><strong>计算协方差矩阵</strong>:</li>
</ol>
<ul>
<li>计算数据的协方差矩阵。协方差矩阵能够捕捉数据特征之间的相关性。</li>
<li>$m\times m$</li>
</ul>
<ol>
<li><strong>求协方差矩阵的特征值和特征向量</strong>:</li>
</ol>
<ul>
<li>计算协方差矩阵的特征值和特征向量。特征向量表示数据的主成分方向，而特征值表示这些方向上的方差大小。</li>
<li>特征向量 $m\times 1$, 特征值$1$，特征值和特征向量可能有多个，但都一一对应。</li>
</ul>
<ol>
<li><strong>排序和选择主成分</strong>:</li>
</ol>
<ul>
<li>根据特征值的大小对特征值和特征向量进行排序，并选择前$k$个最大的特征值对应的特征向量，其中$k$是你想要降低到的维度。</li>
<li>每个特征向量 $m\times 1$，原始数据 $n\times m$，因此每个特征向量可以得到一个 $[n\times m] \times [m \times 1]$ 的 $n \times 1$向量。</li>
</ul>
<ol>
<li><strong>投影数据</strong>:</li>
</ol>
<ul>
<li>将原始数据投影到选定的主成分上，得到降维后的数据。</li>
<li>$k$个特征值得到了$k$个$n\times 1$向量，组合为$n\times k$的矩阵，降维完成。</li>
</ul>
<p><strong>特点</strong>:</p>
<ol>
<li><strong>无监督</strong>:</li>
</ol>
<ul>
<li>PCA 是一种无监督的降维技术，不需要任何标签信息，只依赖于数据的结构。</li>
</ul>
<ol>
<li><strong>线性降维</strong>:</li>
</ol>
<ul>
<li>PCA 只能捕捉数据的线性结构，如果数据具有非线性结构，PCA 可能不是最好的选择。</li>
</ul>
<ol>
<li><strong>方差最大化</strong>:</li>
</ol>
<ul>
<li>PCA 试图找到能够最大化数据方差的主成分，这意味着它倾向于保留数据中的主要结构和模式。</li>
</ul>
<ol>
<li><strong>降噪</strong>:</li>
</ol>
<ul>
<li>通过保留数据中的主要成分并忽略较小的成分，PCA 也可以用于降噪。</li>
</ul>
<ol>
<li><strong>可视化</strong>:</li>
</ol>
<ul>
<li>PCA 可以用于将高维数据降低到 2 或 3 维，以便于可视化。</li>
</ul>
<p><strong>缺点</strong>：</p>
<p>使得原本可解释的数据失去了可解释性。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="category-chain-item">机器学习</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%AD%A6%E6%9C%AF/" class="print-no-link">#学术</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>如何准备机器学习工程师的面试？</div>
      <div>http://songguokunsgg.github.io/2024/02/13/如何准备机器学习工程师的面试__EberyThingSay/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Fansong Yan</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年2月13日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/02/21/%E8%BF%B7%E4%BD%A0%E4%B8%BB%E6%9C%BA%E6%B5%85%E8%B0%88_EberyThingSay/" title="迷你主机浅谈">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">迷你主机浅谈</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/25/2022_%E5%B9%B4%E7%94%A8Wayland%E5%BC%80%E5%90%AFlinux_EberyThingSay/" title="2022 年，用 Wayland 开启 linux">
                        <span class="hidden-mobile">2022 年，用 Wayland 开启 linux</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"lvlxAX7h8N0UYVZ8XQr3vW7e-gzGzoHsz","appKey":"0RaTUR0yFhlAjxM4uYyXvPSj","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
